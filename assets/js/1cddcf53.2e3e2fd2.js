"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[54320],{83610:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var t=i(85893),s=i(11151);const r={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",tags:["Array","Binary Search","Dynamic Programming","Sliding Window","Rolling Hash","Hash Function"]},a="0718 - Maximum Length of Repeated Subarray (Medium)",o={id:"0700-0799/maximum-length-of-repeated-subarray-medium",title:"0718 - Maximum Length of Repeated Subarray (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",source:"@site/solutions/0700-0799/0718-maximum-length-of-repeated-subarray-medium.md",sourceDirName:"0700-0799",slug:"/0700-0799/maximum-length-of-repeated-subarray-medium",permalink:"/solutions/0700-0799/maximum-length-of-repeated-subarray-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0718-maximum-length-of-repeated-subarray-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Binary Search",permalink:"/solutions/tags/binary-search"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Sliding Window",permalink:"/solutions/tags/sliding-window"},{label:"Rolling Hash",permalink:"/solutions/tags/rolling-hash"},{label:"Hash Function",permalink:"/solutions/tags/hash-function"}],version:"current",sidebarPosition:718,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-length-of-repeated-subarray/",tags:["Array","Binary Search","Dynamic Programming","Sliding Window","Rolling Hash","Hash Function"]},sidebar:"tutorialSidebar",previous:{title:"0713 - Subarray Product Less Than K (Medium)",permalink:"/solutions/0700-0799/subarray-product-less-than-k-medium"},next:{title:"0724 - Find Pivot Index (Easy)",permalink:"/solutions/0700-0799/find-pivot-index-easy"}},l={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2},{value:"Approach 2: Binary Search",id:"approach-2-binary-search",level:2}];function h(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...n.components},{SolutionAuthor:i,TabItem:r,Tabs:a}=e;return i||d("SolutionAuthor",!0),r||d("TabItem",!0),a||d("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"0718---maximum-length-of-repeated-subarray-medium",children:"0718 - Maximum Length of Repeated Subarray (Medium)"}),"\n",(0,t.jsx)(e.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"https://leetcode.com/problems/maximum-length-of-repeated-subarray/",children:"https://leetcode.com/problems/maximum-length-of-repeated-subarray/"})}),"\n",(0,t.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsxs)(e.p,{children:["Given two integer arrays ",(0,t.jsx)(e.code,{children:"nums1"})," and ",(0,t.jsx)(e.code,{children:"nums2"}),", return ",(0,t.jsxs)(e.em,{children:["the maximum length of a subarray that appears in ",(0,t.jsx)(e.strong,{children:"both"})," arrays"]}),"."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example 1:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\nOutput: 3\nExplanation: The repeated subarray with maximum length is [3,2,1].\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example 2:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\nOutput: 5\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Constraints:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"1 <= nums1.length, nums2.length <= 1000"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:"0 <= nums1[i], nums2[i] <= 100"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"approach-1-dynamic-programming",children:"Approach 1: Dynamic Programming"}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsxs)(r,{value:"cpp",label:"C++",children:[(0,t.jsx)(i,{name:"@wingkwong"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"class Solution {\npublic:\n    // DP Approach - Similar to 1143. Longest Common Subsequence\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size(), ans = 0;\n        // dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\n        // initially the first row (i = 0) and the first col (j = 0) would be zero\n        // dp[i][0] = 0 for all i and dp[0][j] = 0 for all j\n        // if you use int dp[n + 1][m + 1], then you need to take care of this part\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                // if both character is same\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    // then we add 1 to the previous state, which is dp[i - 1][j - 1]\n                    // in other word, we extend the repeated subarray by 1\n                    // e.g. a = [1], b = [1], length of repeated array is 1\n                    //      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    // record the max ans here\n                    ans = max(ans, dp[i][j]);\n                } else {\n                    // if you are looking for longest common sequence,\n                    // then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\n                    // however, this problem is looking for subarray,\n                    // since both character is not equal, which means we need to break it here\n                    // hence, set dp[i][j] to 0\n                    // since we use vector<vector<int>> dp instead of int dp[n + 1][m + 1]\n                    // this part can be skipped as it is already 0\n                }\n            }\n        }\n        return ans;\n    }\n};\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"class Solution {\npublic:\n    // DP Approach - Space Optimized\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size(), m = nums2.size(), ans = 0;\n        // swap it to ensure n > m\n        if (n < m) {\n            // or you can call findLength(nums2, nums1); \n            swap(nums1, nums2);\n            swap(n, m);\n        }\n        // dp records current dp state\n        // dp2 records the previous dp state\n        vector<int> dp(n + 1), dp2(n + 1);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    // extend from the previous dp state\n                    dp[j] = dp2[j - 1] + 1; \n                } else {\n                    // reset to 0\n                    dp[j] = 0;\n                }\n                // record the max length\n                ans = max(ans, dp[j]);\n            }\n            // the current state now becomes the previous state for next round\n            dp2 = dp;\n        }\n        return ans;\n    }\n};\n"})})]}),(0,t.jsxs)(r,{value:"py",label:"Python",children:[(0,t.jsx)(i,{name:"@wingkwong"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-py",children:"class Solution:\n    # DP Approach - Similar to 1143. Longest Common Subsequence\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        ans = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # if both character is same\n                if nums1[i - 1] == nums2[j - 1]:\n                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]\n                    # in other word, we extend the repeated subarray by 1\n                    # e.g. a = [1], b = [1], length of repeated array is 1\n                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    # record the max ans here\n                    ans = max(ans, dp[i][j])\n                # else:\n                    # if you are looking for longest common sequence,\n                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\n                    # however, this problem is looking for subarray,\n                    # since both character is not equal, which means we need to break it here\n                    # hence, set dp[i][j] to 0\n        return ans\n"})})]})]}),"\n",(0,t.jsx)(e.h2,{id:"approach-2-binary-search",children:"Approach 2: Binary Search"}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsxs)(r,{value:"cpp",label:"C++",children:[(0,t.jsx)(i,{name:"@wingkwong"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Binary Search + Rolling Hash Approach\nclass Solution {\npublic:\n    // the idea is to use binary search to find the length `m`\n    // then we check if there is any nums1[i : i + m] == nums2[i : i + m]\n    // for c++, it may get TLE. so we can use rolling hash to speed up\n    // we can see `nums1[i : j]` as a hash, then we insert all the possible hashes to a set\n    // then we do the same on `nums2` to see if the hash exists in the set\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int N = nums1.size(), M = nums2.size();\n        // build hashes for nums1\n        PolyHash H1 = PolyHash(nums1);\n        // build hashes for nums2\n        PolyHash H2 = PolyHash(nums2);\n        \n        int l = 0, r = min(N, M);\n        // binary search\n        while (l < r) {\n            // guess that the length is m\n            int m = l + (r - l + 1) / 2, ok = 0;\n            // use set to store all the possible hashes\n            set<int> s;\n            // for each subarray, we get the hash and store in set\n            for (int i = 0; i < N - m + 1; i++) {\n                s.insert(H1.get_hash(i, i + m - 1));\n            }\n            // see if we can get the same hash\n            for (int i = 0; i < M - m + 1; i++) {\n                if (s.find(H2.get_hash(i, i + m - 1)) != s.end()) {\n                    ok = 1;\n                    break;\n                }\n            }\n            // include m\n            if (ok) l = m;\n            // exclude m\n            else r = m - 1;\n        }\n        return l;\n    }\n};\n"})})]}),(0,t.jsxs)(r,{value:"py",label:"Python",children:[(0,t.jsx)(i,{name:"@wingkwong"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-py",children:"class Solution:\n    # Binary Search Approach\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        N, M = len(nums1), len(nums2)\n        \n        def ok(k):\n            # the idea is to use binary search to find the length `k`\n            # then we check if there is any nums1[i : i + k] == nums2[i : i + k]\n            s = set(tuple(nums1[i : i + k]) for i in range(N - k + 1))\n            return any(tuple(nums2[i : i + k]) in s for i in range(M - k + 1))\n        \n        # init possible boundary\n        l, r = 0, min(N, M)\n        while l < r:\n            # get the middle one\n            # for even number of elements, take the upper one\n            m = (l + r + 1) // 2\n            if ok(m): \n                # include m\n                l = m\n            else:\n                # exclude m\n                r = m - 1\n        return l\n"})})]})]})]})}function u(n={}){const{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}function d(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(n,e,i)=>{i.d(e,{Z:()=>o,a:()=>a});var t=i(67294);const s={},r=t.createContext(s);function a(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);