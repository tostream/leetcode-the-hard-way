"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[46681],{20810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var i=t(85893),r=t(11151);const s={description:"Author: @wingkwong | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",tags:["Array","Breadth-First Search","Matrix"]},o="1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)",a={id:"1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard",title:"1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",source:"@site/solutions/1200-1299/1293-shortest-path-in-a-grid-with-obstacles-elimination-hard.md",sourceDirName:"1200-1299",slug:"/1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard",permalink:"/solutions/1200-1299/shortest-path-in-a-grid-with-obstacles-elimination-hard",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1200-1299/1293-shortest-path-in-a-grid-with-obstacles-elimination-hard.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Matrix",permalink:"/solutions/tags/matrix"}],version:"current",sidebarPosition:1293,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",tags:["Array","Breadth-First Search","Matrix"]},sidebar:"tutorialSidebar",previous:{title:"1281 - Subtract the Product and Sum of Digits of an Integer (Easy)",permalink:"/solutions/1200-1299/subtract-the-product-and-sum-of-digits-of-an-integer-easy"},next:{title:"1299 - Replace Elements with Greatest Element on Right Side",permalink:"/solutions/1200-1299/replace-elements-with-greatest-element-on-right-side-easy"}},l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: BFS",id:"approach-1-bfs",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{SolutionAuthor:t,TabItem:s,Tabs:o}=n;return t||m("SolutionAuthor",!0),s||m("TabItem",!0),o||m("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"1293---shortest-path-in-a-grid-with-obstacles-elimination-hard",children:"1293 - Shortest Path in a Grid with Obstacles Elimination (Hard)"}),"\n",(0,i.jsx)(n.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",children:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/"})}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(n.p,{children:["You are given an ",(0,i.jsx)(n.code,{children:"m x n"})," integer matrix ",(0,i.jsx)(n.code,{children:"grid"})," where each cell is either ",(0,i.jsx)(n.code,{children:"0"})," (empty) or ",(0,i.jsx)(n.code,{children:"1"})," (obstacle). You can move up, down, left, or right from and to an empty cell in ",(0,i.jsx)(n.strong,{children:"one step"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Return ",(0,i.jsxs)(n.em,{children:["the minimum number of ",(0,i.jsx)(n.strong,{children:"steps"})," to walk from the upper left corner"]}),(0,i.jsx)(n.code,{children:"(0, 0)"}),(0,i.jsx)(n.em,{children:"to the lower right corner"}),(0,i.jsx)(n.code,{children:"(m - 1, n - 1)"}),(0,i.jsxs)(n.em,{children:["given that you can eliminate ",(0,i.jsx)(n.strong,{children:"at most"})]}),(0,i.jsx)(n.code,{children:"k"}),(0,i.jsx)(n.em,{children:"obstacles"}),". If it is not possible to find such walk return ",(0,i.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 1:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\nOutput: 6\nExplanation: \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example 2:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\nOutput: -1\nExplanation: We need to eliminate at least two obstacles to find such a walk.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m == grid.length"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"n == grid[i].length"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= m, n <= 40"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"1 <= k <= m * n"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"grid[i][j]"})," is either ",(0,i.jsx)(n.code,{children:"0"})," ",(0,i.jsx)(n.strong,{children:"or"})," ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"grid[0][0] == grid[m - 1][n - 1] == 0"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"approach-1-bfs",children:"Approach 1: BFS"}),"\n",(0,i.jsx)(o,{children:(0,i.jsxs)(s,{value:"cpp",label:"C++",children:[(0,i.jsx)(t,{name:"@wingkwong"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Solution {\npublic:\n    // 4 directions \n    const int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\n    // if you are working on 8 directions, then you can use\n    // const int dx[8]= { -1, 0, 0, 1, -1, -1, 1, 1 },\n    //           dy[8]= { 0, 1, -1, 0, -1, 1, -1, 1 };\n    \n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size(), n = grid[0].size(), steps = 0;\n        vector<vector<int>> remains(m, vector<int>(n, INT_MIN));\n        // we have a queue storing {x, y, k} \n        // where x and y are coordinate \n        // and r is remain number of obstacles you can remove\n        queue<array<int, 3>> q;\n        // we start at (0, 0) with k\n        q.push({0, 0, k});\n        // at the beginning, you can eliminate at most k obstacles\n        remains[0][0] = k;\n        // BFS\n        while (!q.empty()) {\n            for (int it = q.size(); it > 0; it--) {\n                auto cur = q.front(); q.pop();\n                // if we reach the lower right corner (m - 1, n - 1)\n                // then return the minimum number of steps\n                if (cur[0] == m - 1 && cur[1] == n - 1) return steps;\n                // otherwise we can try 4 directions (up, down, left and right)\n                for (int i = 0; i < 4; i++) {\n                    // given we have at (x, y), we can move to (next_x, next_y)\n                    int next_x = cur[0] + dx[i], next_y = cur[1] + dy[i];\n                    // however, first we need to make sure (next_x, next_y) is within the grid\n                    if(next_x < 0 || next_x >= m || next_y < 0 || next_y >= n) continue;\n                    // then, we check if we can eliminate an obstacle and move there\n                    int remain = cur[2] - grid[next_x][next_y];\n                    // we can only do that when `remain` is greater or equal to 0\n                    // and the target remaining k must be less than the current remaining k\n                    if(remain >= 0 && remains[next_x][next_y] < remain) {\n                        // push to the queue for further process\n                        q.push({next_x, next_y, remain});\n                        // update the remaining k\n                        remains[next_x][next_y] = remain;\n                    }\n                }\n            }\n            // increase step count\n            steps += 1;\n        }\n        // if we reach here, \n        // then it means it is not possible to find such walk \n        return -1;\n    }\n};\n\n"})})]})})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(67294);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);