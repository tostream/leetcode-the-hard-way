"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[80079],{87641:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var a=t(85893),n=t(11151);const r={title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",keywords:["leetcode","tutorial","bellman ford","algorithm"]},i=void 0,l={id:"graph-theory/bellman-ford-algorithm",title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",source:"@site/tutorials/graph-theory/bellman-ford-algorithm.md",sourceDirName:"graph-theory",slug:"/graph-theory/bellman-ford-algorithm",permalink:"/tutorials/graph-theory/bellman-ford-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/bellman-ford-algorithm.md",tags:[],version:"current",frontMatter:{title:"Bellman Ford Algorithm",description:"Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph",keywords:["leetcode","tutorial","bellman ford","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/tutorials/graph-theory/introduction"},next:{title:"Binary Search Tree",permalink:"/tutorials/graph-theory/binary-search-tree"}},o={},m=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2}];function h(e){const s={annotation:"annotation",code:"code",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,n.a)(),...e.components},{SolutionAuthor:t,TabItem:r,Tabs:i,TutorialAuthors:l}=s;return t||d("SolutionAuthor",!0),r||d("TabItem",!0),i||d("Tabs",!0),l||d("TutorialAuthors",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(l,{names:"@wingkwong"}),"\n",(0,a.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(s.p,{children:["Bellman Ford Algorithm computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. Similar to Dijkstra's algorithm, it proceeds by relaxation. However, Dijkstra's algorithm uses a priority queue to greedily select the closest vertex that has not been processed, which all of its outgoing edges will be processed. On the other hand, Bellman Ford Algorithm relaxes all the edges and does the relaxation only ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(s.mi,{children:"V"}),(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(s.mo,{children:"\u2212"}),(0,a.jsx)(s.mn,{children:"1"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"|V| - 1"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(s.span,{className:"mord",children:"1"})]})]})]})," times where ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(s.mi,{children:"V"}),(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"|V|"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"})]})})]})," is the number of vertices in the graph. This is because given a graph with no negative weight cycles with ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"V"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"V"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"})]})})]})," vertices, the shortest path between any two vertices has at most ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(s.mi,{children:"V"}),(0,a.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,a.jsx)(s.mo,{children:"\u2212"}),(0,a.jsx)(s.mn,{children:"1"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"|V| - 1"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),(0,a.jsx)(s.span,{className:"mord",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(s.span,{className:"mord",children:"1"})]})]})]})," edges."]}),"\n",(0,a.jsx)(s.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsxs)(r,{value:"cpp",label:"C++",children:[(0,a.jsx)(t,{name:"@wingkwong"}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-cpp",children:"template<typename T_a3, typename T_vector>\nvoid bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n    dist[src] = 0;\n    for (int i = 0; i <= mx_edges; i++) {\n        T_vector ndist = dist;\n        for (auto x : g) {\n            auto [from, to, cost] = x;\n            ndist[to] = min(ndist[to], dist[from] + cost);\n        }\n        dist = ndist;\n    }\n}\n"})})]}),(0,a.jsxs)(r,{value:"py",label:"Python",children:[(0,a.jsx)(t,{name:"@Odion-Sonny"}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-py",children:"def bellman_ford(g, dist, src, mx_edges):\n    dist[src] = 0\n    for i in range(mx_edges + 1):\n        ndist = dist[:]\n        for x in g:\n            _from, to, cost = x\n            ndist[to] = min(ndist[to], dist[_from] + cost)\n        dist = ndist\n    return dist\n"})})]})]})]})}function c(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}function d(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,s,t)=>{t.d(s,{Z:()=>l,a:()=>i});var a=t(67294);const n={},r=a.createContext(n);function i(e){const s=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);