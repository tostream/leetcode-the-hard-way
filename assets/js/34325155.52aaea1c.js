"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[70879],{6545:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>u});var r=i(85893),s=i(11151);const t={description:"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/",tags:["Array","Hash Table","Prefix Sum"]},a="0974 - Subarray Sums Divisible by K (Medium)",o={id:"0900-0999/subarray-sums-divisible-by-k-medium",title:"0974 - Subarray Sums Divisible by K (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/",source:"@site/solutions/0900-0999/0974-subarray-sums-divisible-by-k-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/subarray-sums-divisible-by-k-medium",permalink:"/solutions/0900-0999/subarray-sums-divisible-by-k-medium",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0974-subarray-sums-divisible-by-k-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Prefix Sum",permalink:"/solutions/tags/prefix-sum"}],version:"current",sidebarPosition:974,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/subarray-sums-divisible-by-k/",tags:["Array","Hash Table","Prefix Sum"]},sidebar:"tutorialSidebar",previous:{title:"0973 - K Closest Points to Origin (Medium)",permalink:"/solutions/0900-0999/k-closest-points-to-origin-medium"},next:{title:"0976 - Largest Perimeter Triangle (Easy)",permalink:"/solutions/0900-0999/largest-perimeter-triangle-easy"}},l={},u=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map + Prefix Sum",id:"approach-1-hash-map--prefix-sum",level:2}];function p(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...n.components},{SolutionAuthor:i,TabItem:t,Tabs:a}=e;return i||c("SolutionAuthor",!0),t||c("TabItem",!0),a||c("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"0974---subarray-sums-divisible-by-k-medium",children:"0974 - Subarray Sums Divisible by K (Medium)"}),"\n",(0,r.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(e.p,{children:["Given an integer array ",(0,r.jsx)(e.code,{children:"nums"})," and an integer ",(0,r.jsx)(e.code,{children:"k"}),", return ",(0,r.jsxs)(e.em,{children:["the number of non-empty ",(0,r.jsx)(e.strong,{children:"subarrays"})," that have a sum divisible by"]}),(0,r.jsx)(e.code,{children:"k"}),"."]}),"\n",(0,r.jsxs)(e.p,{children:["A ",(0,r.jsx)(e.strong,{children:"subarray"})," is a ",(0,r.jsx)(e.strong,{children:"contiguous"})," part of an array."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example 1:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Input: nums = [4,5,0,-2,-3,1], k = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example 2:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Input: nums = [5], k = 9\nOutput: 0\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Constraints:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"1 <= nums.length <= 3 * 10^4"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"-10^4 <= nums[i] <= 10^4"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"2 <= k <= 10^4"})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"approach-1-hash-map--prefix-sum",children:"Approach 1: Hash Map + Prefix Sum"}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsxs)(t,{value:"cpp",label:"C++",children:[(0,r.jsx)(i,{name:"@wingkwong"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"class Solution {\npublic:\n    vector<int> generatePrefixSum(vector<int>& a) {\n        int n = a.size();\n        vector<int> pref(n);\n        pref[0] = a[0];\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\n        return pref;\n    }\n\n    int subarraysDivByK(vector<int>& nums, int k) {\n        // generate prefix sum\n        vector<int> pref = generatePrefixSum(nums);\n        // store the modular cnt\n        vector<int> m(k);\n        // base value\n        m[0] = 1;\n        // init ans\n        int ans = 0;\n        // iterate each sum\n        for (auto& x : pref) {\n            // if x is negative, turn it to positive modular equivalent\n            if (x < 0) x = (x % k + k) % k;\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k]++;\n        }\n        // n choose 2\n        for (auto& x : m) ans += x * (x - 1) / 2;\n        return ans;\n    }\n};\n"})})]}),(0,r.jsxs)(t,{value:"java",label:"Java",children:[(0,r.jsx)(i,{name:"@wingkwong"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        // generate prefix sum\n        int[] pref = new int[nums.length];\n        pref[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            pref[i] = pref[i - 1] + nums[i];\n        }\n        // store the modular cnt\n        int[] m = new int[k];\n        // base value\n        m[0] = 1;\n        // init ans\n        int ans = 0;\n        // iterate each sum\n        for (int x : pref) {\n            // if x is negative, turn it to positive modular equivalent\n            if (x < 0) {\n                x = (x % k + k) % k;\n            }\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k]++;\n        }\n        // n choose 2\n        for (int x : m) {\n            ans += x * (x - 1) / 2;\n        }\n        return ans;\n    }\n}\n\n"})})]}),(0,r.jsxs)(t,{value:"py",label:"Python",children:[(0,r.jsx)(i,{name:"@wingkwong"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:"class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        # generate prefix sum\n        pref = [0] * len(nums)\n        pref[0] = nums[0]\n        for i in range(1, len(nums)):\n            pref[i] = pref[i-1] + nums[i]\n        \n        # store the modular cnt\n        m = [0] * k\n        # base value\n        m[0] = 1\n        # init ans\n        ans = 0\n        # iterate each sum\n        for x in pref:\n            # we don't need the following logic as Python handles it internally \n            # if x is negative, turn it to positive modular equivalent\n            # if x < 0:\n            #     x = (x % k + k) % k\n            # we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            # hence, we look for pref[j] % k == pref[i] % k\n            # why ..? \n            # pref[j] = a * k + x\n            # pref[i] = b * k + y\n            # pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            # pref[j] - pref[i] = k * (a - b) + (x - y)\n            # -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[x % k] += 1\n        # n choose 2\n        for x in m:\n            ans += x * (x - 1) // 2\n        return ans\n"})})]}),(0,r.jsxs)(t,{value:"rs",label:"Rust",children:[(0,r.jsx)(i,{name:"@wingkwong"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rs",children:"impl Solution {\n    pub fn subarrays_div_by_k(nums: Vec<i32>, k: i32) -> i32 {\n        // generate prefix sum\n        let mut pref = vec![0; nums.len()];\n        pref[0] = nums[0];\n        for i in 1 .. nums.len() {\n            pref[i] = pref[i - 1] + nums[i];\n        }\n        // store the modular cnt\n        let mut m = vec![0; k as usize];\n        // base value\n        m[0] = 1;\n        // init ans\n        let mut ans = 0;\n        // iterate each sum\n        for x in pref.iter_mut() {\n            // if x is negative, turn it to positive modular equivalent\n            if *x < 0 {\n                *x = (*x % k + k) % k;\n            }\n            // we need to find pairs such that (pref[j] - pref[i]) % k == 0\n            // hence, we look for pref[j] % k == pref[i] % k\n            // why ..? \n            // pref[j] = a * k + x\n            // pref[i] = b * k + y\n            // pref[j] - pref[i] = (a * k + x) - (b * k + y)\n            // pref[j] - pref[i] = k * (a - b) + (x - y)\n            // -> (pref[j] - pref[i]) % k == 0 if & only if (x - y) == 0\n            m[(*x % k) as usize] += 1;\n        }\n        // n choose 2\n        for x in m {\n            ans += x * (x - 1) / 2;\n        }\n        ans\n    }\n}\n\n"})})]})]})]})}function m(n={}){const{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}function c(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(n,e,i)=>{i.d(e,{Z:()=>o,a:()=>a});var r=i(67294);const s={},t=r.createContext(s);function a(n){const e=r.useContext(t);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);