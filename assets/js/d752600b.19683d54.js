"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[9546],{34791:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var r=n(85893),s=n(11151);const o={description:"Author: @heiheihang, @wingkwong, @jit | https://leetcode.com/problems/sum-of-left-leaves/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},l="0404 - Sum of Left Leaves (Easy)",i={id:"0400-0499/sum-of-left-leaves-easy",title:"0404 - Sum of Left Leaves (Easy)",description:"Author: @heiheihang, @wingkwong, @jit | https://leetcode.com/problems/sum-of-left-leaves/",source:"@site/solutions/0400-0499/0404-sum-of-left-leaves-easy.md",sourceDirName:"0400-0499",slug:"/0400-0499/sum-of-left-leaves-easy",permalink:"/solutions/0400-0499/sum-of-left-leaves-easy",draft:!1,unlisted:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0404-sum-of-left-leaves-easy.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:404,frontMatter:{description:"Author: @heiheihang, @wingkwong, @jit | https://leetcode.com/problems/sum-of-left-leaves/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0403 - Frog Jump (Hard)",permalink:"/solutions/0400-0499/Frog-Jump"},next:{title:"0413 - Arithmetic Slices (Medium)",permalink:"/solutions/0400-0499/arithmetic-slices-medium"}},a={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{SolutionAuthor:n,TabItem:o,Tabs:l}=t;return n||f("SolutionAuthor",!0),o||f("TabItem",!0),l||f("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"0404---sum-of-left-leaves-easy",children:"0404 - Sum of Left Leaves (Easy)"}),"\n",(0,r.jsx)(t.h2,{id:"problem-link",children:"Problem Link"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://leetcode.com/problems/sum-of-left-leaves/",children:"https://leetcode.com/problems/sum-of-left-leaves/"})}),"\n",(0,r.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(t.p,{children:["Given the ",(0,r.jsx)(t.code,{children:"root"})," of a binary tree, return the sum of all left leaves."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example 1:"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg",alt:""})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Input: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example 2:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Input: root = [1]\nOutput: 0 \n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Constraints:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The number of nodes in the tree is in the range ",(0,r.jsx)(t.code,{children:"[1, 1000]"}),"."]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"-1000 <= Node.val <= 1000"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"approach-1-dfs",children:"Approach 1: DFS"}),"\n",(0,r.jsxs)(t.p,{children:["Following the template from ",(0,r.jsx)(t.a,{href:"../../tutorials/graph-theory/depth-first-search",children:"DFS Guide"}),", we iterate to each node and check if it is a left leaf. If it is a left leaf, we return that value to its parent for cumulating the sum. The trick here is to add a ",(0,r.jsx)(t.code,{children:"is_left"})," parameter to the ",(0,r.jsx)(t.code,{children:"dfs"})," function."]}),"\n",(0,r.jsxs)(l,{children:[(0,r.jsxs)(o,{value:"py",label:"Python",children:[(0,r.jsx)(n,{name:"@heiheihang"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:"def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n    def dfs(node, isLeft):\n        # skip when we reach the end of the path\n        if (node is None): return 0\n        # if node is a leaf (no left and right) and is the left child\n        # return its value for adding\n        if (node.left is None and node.right is None and isLeft is True): return node.val \n        # perform dfs on both children\n        # set isLeft to true on left child\n        # set isLeft to false on right child\n        return dfs(node.left, True) + dfs(node.right, False)\n    # root can be a leaf if it is the only node in the tree\n    # but it is not a left leaf (no right/left)\n    return dfs(root, False)\n"})})]}),(0,r.jsxs)(o,{value:"cpp",label:"C++",children:[(0,r.jsx)(n,{name:"@wingkwong"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:"class Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root, bool left = false) {\n        // use left flag to determine it is a left node\n        // traverse each node and only return if left=true and no child branches\n        if(!root) return 0;\n        if(left && !root->left && !root->right) return root->val;\n        return sumOfLeftLeaves(root->left, true) + sumOfLeftLeaves(root->right, false);\n    }\n};\n"})})]}),(0,r.jsxs)(o,{value:"elixir",label:"Elixir",children:[(0,r.jsx)(n,{name:"@jit"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-elixir",children:"defmodule Solution do\n  # Using a left/right flag:\n  @spec sum_of_left_leaves(root :: TreeNode.t | nil) :: integer\n  def sum_of_left_leaves(root), do: dfs(root, :neither)\n\n  defp dfs(nil, _flag), do: 0\n  defp dfs(%{val: v, left: nil, right: nil}, :left), do: v\n  defp dfs(%{left: l, right: r}, _flag), do:\n    dfs(l, :left) + dfs(r,\n"})})]})]})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function f(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>l});var r=n(67294);const s={},o=r.createContext(s);function l(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);